{
  "version": 3,
  "sources": ["../src/lib/parse.js", "../src/lib/args.js", "../src/lib/fn.js", "../src/lib/bitstr.js", "../src/index.js"],
  "sourcesContent": ["const debug = false\n\n// parse(str) -> expr\n// > Parses a string into a boolean expression.\n// > A boolean expression is a list of tokens.\n// > Ideally, these token lists should be\n// > able to be converted into functions.\nmodule.exports = function parse(str) {\n\tlet stack = []\n\tfor (let i = 0; i < str.length; i++) {\n\t\tlet chr = str[i]\n\t\tif (chr === \" \") continue\n\t\tif (debug) console.log(chr, stack)\n\t\tlet node = stack[stack.length - 1]\n\t\tlet parent = stack[stack.length - 2]\n\t\tif (!node && chr !== \"(\" && chr !== \")\") {\n\t\t\t// first pass\n\t\t\t// all operators invalid, so throw if we find one\n\t\t\tif (chr === \"'\") {\n\t\t\t\tthrow new Error(\"Failed to parse boolean expression \" + str\n\t\t\t\t\t+ \": Cannot NOT an undefined clause\")\n\t\t\t}\n\t\t\tif (chr === \"+\") {\n\t\t\t\tthrow new Error(\"Failed to parse boolean expression \" + str\n\t\t\t\t\t+ \": Cannot OR an undefined clause\")\n\t\t\t}\n\t\t\t// this var is our token for now in case we terminate here\n\t\t\tstack.push(chr)\n\t\t\tcontinue\n\t\t}\n\n\t\tif (chr === \"(\") {\n\t\t\tif (!node) {\n\t\t\t\t// start a new group\n\t\t\t\tlet grp = [ \"grp\" ]\n\t\t\t\tstack.push(grp)\n\t\t\t} else if (node[0] === \"grp\" && node.length === 1\n\t\t\t\t|| node[0] === \"or\" && node.length === 2\n\t\t\t\t) {\n\t\t\t\t// same procedure for nested groups and OR clauses\n\t\t\t\tlet grp = [ \"grp\" ]\n\t\t\t\tstack.push(grp)\n\t\t\t\tnode.push(grp)\n\t\t\t} else {\n\t\t\t\t// AND clause with a group in form x(y)\n\t\t\t\tlet grp = [ \"grp\" ]\n\t\t\t\tlet and = [ \"and\", node, grp ]\n\t\t\t\tstack[stack.length - 1] = and\n\t\t\t\tstack.push(grp)\n\t\t\t\tif (parent) parent[parent.length - 1] = and\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif (chr === \")\") {\n\t\t\t// find closest open paren\n\t\t\tlet token = null\n\t\t\twhile (stack.length && (!token || token[0] !== \"grp\")) {\n\t\t\t\ttoken = stack.pop()\n\t\t\t}\n\t\t\tif (!token || token[0] !== \"grp\") {\n\t\t\t\tthrow new Error(\"Failed to parse boolean expression \" + str\n\t\t\t\t\t+ \": Cannot terminate an undefined clause\")\n\t\t\t}\n\t\t\tif (!token[1]) {\n\t\t\t\tthrow new Error(\"Failed to parse boolean expression \" + str\n\t\t\t\t\t+ \": Cannot parse an empty group\")\n\t\t\t}\n\t\t\t// replace with contents\n\t\t\tif (debug) console.log(\"ended group\", token)\n\t\t\tstack.push(token[1])\n\t\t\tparent = stack[stack.length - 2]\n\t\t\tif (parent) parent[parent.length - 1] = token[1]\n\t\t\tcontinue\n\t\t}\n\n\t\tif (chr === \"'\") {\n\t\t\t// create token: NOT inverse of most recent var\n\t\t\t// replace var with inverse in stack\n\t\t\t// replace var with inverse in parent if existent\n\t\t\t// point to NOT node\n\t\t\tif (node[0] === \"or\" && node.length === 2) {\n\t\t\t\tthrow new Error(\"Failed to parse boolean expression \" + str\n\t\t\t\t\t+ \": Cannot NOT an incomplete OR clause\")\n\t\t\t}\n\t\t\tif (node[0] === \"grp\") {\n\t\t\t\tthrow new Error(\"Failed to parse boolean expression \" + str\n\t\t\t\t\t+ \": Cannot NOT an lparen\")\n\t\t\t}\n\t\t\tlet not = [ \"not\", node ]\n\t\t\tstack[stack.length - 1] = not\n\t\t\tif (parent) parent[parent.length - 1] = not\n\t\t\tcontinue\n\t\t}\n\n\t\tif (chr === \"+\") {\n\t\t\t// create token: OR with highest level non-grouped parent\n\t\t\t// point to OR node\n\t\t\tif (node[0] === \"or\" && node.length === 2) {\n\t\t\t\tthrow new Error(\"Failed to parse boolean expression \" + str\n\t\t\t\t\t+ \": Cannot OR an incomplete OR clause\")\n\t\t\t}\n\t\t\tlet parent = null\n\t\t\tlet group = null\n\t\t\tlet i = stack.length\n\t\t\twhile (i) {\n\t\t\t\tparent = stack[--i]\n\t\t\t\tif (parent[0] === \"grp\") {\n\t\t\t\t\tgroup = parent\n\t\t\t\t\tparent = parent[1]\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet or = [ \"or\", parent ]\n\t\t\t// prevent overwriting grouped nodes\n\t\t\t// elsewise rparen will lock\n\t\t\tif (!group) {\n\t\t\t\tstack.length = i\n\t\t\t\tstack.push(or)\n\t\t\t} else {\n\t\t\t\tstack.length = i + 1\n\t\t\t\tstack.push(or)\n\t\t\t\tgroup[group.length - 1] = or\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\t// -- if we reach this point, chr is another token\n\n\t\t// complete OR node if it holds the form (or x [nil])\n\t\tif (node[0] === \"or\" && node.length === 2) {\n\t\t\tnode.push(chr)\n\t\t\tstack.push(chr)\n\t\t\tcontinue\n\t\t}\n\n\t\t// complete GRP node if it holds the form (grp [nil])\n\t\t// otherwise, we'll need to AND the current token\n\t\tif (node[0] === \"grp\" && node.length === 1) {\n\t\t\tnode.push(chr)\n\t\t\tstack.push(chr)\n\t\t\tcontinue\n\t\t}\n\n\t\t// create token: AND with prev and current tokens\n\t\t// point to current token (not AND node)\n\t\tlet and = [ \"and\", node, chr ]\n\t\tstack[stack.length - 1] = and\n\t\tstack.push(chr)\n\t\tif (parent) parent[parent.length - 1] = and\n\t}\n\n\tlet token = stack[0]\n\tif (token[0] === \"or\" && token.length === 2) {\n\t\tthrow new Error(\"Failed to parse boolean expression \" + str\n\t\t\t+ \": Incomplete OR clause\")\n\t}\n\tif (token[0] === \"grp\" || stack[stack.length - 1][0] === \"grp\") {\n\t\tthrow new Error(\"Failed to parse boolean expression \" + str\n\t\t\t+ \": Unterminated group\")\n\t}\n\n\treturn token\n}\n", "module.exports = function reduceargs(token) {\n\tlet vars = reducevars(token)\n\tlet args = []\n\tfor (let v of vars) {\n\t\tif (args.indexOf(v) >= 0) continue\n\t\targs.push(v)\n\t}\n\treturn args.sort()\n}\n\nfunction reducevars(token) {\n\tif (!isNaN(Number(token))) return []\n\tif (typeof token === \"string\") return [ token ]\n\tlet [ type, x, y ] = token\n\tif (type === \"not\") return reducevars(x)\n\treturn reducevars(x).concat(reducevars(y))\n}\n", "const reduceargs = require(\"./args\")\n\nmodule.exports = function fnify(token) {\n\tlet str = strify(token)\n\tlet args = reduceargs(token)\n\treturn eval(\"(\" + args.join(\",\") + \")=>\" + str)\n}\n\nfunction strify(token, parent) {\n\tif (typeof token === \"string\") return token\n\tlet [ type, x, y ] = token\n\tif (type === \"not\") {\n\t\treturn \"!\" + strify(x, type)\n\t}\n\tif (type === \"and\") {\n\t\tlet and = strify(x, type) + \"&&\" + strify(y, type)\n\t\tif (parent === \"not\") {\n\t\t\treturn `(${ and })`\n\t\t} else {\n\t\t\treturn and\n\t\t}\n\t}\n\tif (type === \"or\") {\n\t\tlet or = strify(x, type) + \"||\" + strify(y, type)\n\t\tif (parent === \"not\" || parent === \"and\") {\n\t\t\treturn `(${ or })`\n\t\t} else {\n\t\t\treturn or\n\t\t}\n\t}\n}\n", "const fnify = require(\"./fn\")\n\nmodule.exports = function bitstr(token) {\n\tlet bits = \"\"\n\tlet fn = fnify(token)\n\tlet perms = Math.pow(2, fn.length)\n\tfor (let i = 0; i < perms; i++) {\n\t\tlet str = i.toString(2)\n\t\twhile (str.length < fn.length) {\n\t\t\tstr = \"0\" + str\n\t\t}\n\t\tlet argv = str.split(\"\").map(Number)\n\t\tbits += Number(fn(...argv))\n\t}\n\treturn bits\n}\n", "import parse from \"./lib/parse\"\nimport id from \"./lib/bitstr\"\n\nconst form = document.querySelector(\".section.-form\")\nconst outputbox = document.querySelector(\".output-box\")\nconst output = document.querySelector(\".output\")\n\nlet state = {\n\texpr1: {\n\t\ttoken: null,\n\t\tinput: document.querySelector(\"#expr1\"),\n\t\terror: document.querySelector(\".input-error.-expr1\")\n\t},\n\texpr2: {\n\t\ttoken: null,\n\t\tinput: document.querySelector(\"#expr2\"),\n\t\terror: document.querySelector(\".input-error.-expr2\")\n\t}\n}\n\nlisten(state.expr1)\nlisten(state.expr2)\n\nform.onsubmit = event => {\n\tconst { expr1, expr2 } = state\n\tevent.preventDefault()\n\tvalidate(expr1)\n\tvalidate(expr2)\n\tif (expr1.token instanceof Error || expr2.token instanceof Error) {\n\t\treturn\n\t}\n\tlet id1 = id(expr1.token)\n\tlet id2 = id(expr2.token)\n\tif (id1 === id2) {\n\t\toutputbox.classList.remove(\"-incorrect\")\n\t\toutputbox.classList.add(\"-correct\", \"-result\")\n\t\toutput.innerHTML = expr1.input.value + \" = \" + expr2.input.value\n\t} else {\n\t\toutputbox.classList.remove(\"-correct\")\n\t\toutputbox.classList.add(\"-incorrect\", \"-result\")\n\t\toutput.innerHTML = expr1.input.value + \" &NotEqual; \" + expr2.input.value\n\t}\n}\n\nfunction listen(expr) {\n\tconst { input, error } = expr\n\tconst clear = _ => error.innerText = \"\"\n\tinput.onblur = _ => validate(expr)\n\tinput.onkeypress = clear\n\tinput.onpaste = clear\n\tinput.oninput = clear\n}\n\nfunction validate(expr) {\n\tconst { input, error } = expr\n\tif (!input.value) {\n\t\texpr.token = \"\"\n\t} else try {\n\t\texpr.token = parse(input.value)\n\t} catch (err) {\n\t\texpr.token = err\n\t}\n\tif (expr.token && !(expr.token instanceof Error)\n\t&& id(expr.token).length > Math.pow(2, 8)\n\t) {\n\t\texpr.token = new Error(\"Maximum number of vars is 8\")\n\t}\n\tif (expr.token instanceof Error) {\n\t\terror.innerHTML = \"&times; \" + colonslice(expr.token.message)\n\t} else {\n\t\terror.innerText = \"\"\n\t}\n}\n\nfunction colonslice(str) {\n\tfor (var i = str.length; i;) {\n\t\tif (str[--i] === \":\") break\n\t}\n\tif (!i) return str\n\treturn str.slice(i + 2, str.length)\n}\n\nlet year = document.querySelector(\"#year\")\nyear.innerText = new Date().getFullYear()\n"],
  "mappings": "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",
  "names": []
}
